# Buffer Configuration Guide

This guide covers common buffer configurations in Sandalphon. Each buffer type includes its purpose and the recommended `buffer!` parameters.

## Vertex Buffer (GPU-Only)

**Purpose:** Stores vertex data (positions, normals, UVs) for rendering. Read by vertex shaders during draw calls.

**Characteristics:**
- Lives in fast VRAM
- Written once, read many times by GPU
- Not CPU-accessible after upload

**Configuration:**
```clojure
(buffer! device
  :size vertex-data-size
  :usage #{:vertex-buffer :transfer-dst})
```

**Memory Usage:** `:auto-prefer-device` (default)

**Notes:** Use `:transfer-dst` to enable uploading via staging buffer. For static geometry, this is the most efficient configuration.

---

## Index Buffer (GPU-Only)

**Purpose:** Stores vertex indices for indexed drawing, reducing duplicate vertices.

**Characteristics:**
- Lives in fast VRAM
- Read by GPU during indexed draw calls
- Not CPU-accessible after upload

**Configuration:**
```clojure
(buffer! device
  :size index-data-size
  :usage #{:index-buffer :transfer-dst})
```

**Memory Usage:** `:auto-prefer-device` (default)

**Notes:** Similar to vertex buffers. Use 16-bit or 32-bit indices depending on vertex count.

---

## Staging Buffer (CPU → GPU Transfer)

**Purpose:** Temporary buffer for uploading data from CPU to GPU buffers. Used as transfer source.

**Characteristics:**
- Lives in CPU-accessible memory
- Written sequentially by CPU
- Read once by GPU during transfer
- Short-lived (created, filled, transferred, destroyed)

**Configuration:**
```clojure
(buffer! device
  :size data-size
  :usage #{:transfer-src}
  :memory-usage :auto-prefer-host
  :allocation-flags #{:host-access-sequential-write :mapped})
```

**Notes:** The `:mapped` flag keeps the buffer persistently mapped for efficient CPU writes. After transfer command completes, destroy this buffer.

---

## Dynamic Vertex Buffer (Frequently Updated)

**Purpose:** Vertex buffer that updates every frame or frequently (particles, UI, dynamic meshes).

**Characteristics:**
- CPU writes new data each frame
- GPU reads during rendering
- Persistent mapping for low overhead

**Configuration:**
```clojure
(buffer! device
  :size vertex-data-size
  :usage #{:vertex-buffer}
  :memory-usage :auto-prefer-device
  :allocation-flags #{:host-access-sequential-write :mapped})
```

**Notes:** VMA will try to allocate from resizable BAR or HOST_VISIBLE + DEVICE_LOCAL memory if available. Falls back to HOST_VISIBLE memory on older GPUs.

---

## Uniform Buffer (Shader Constants)

**Purpose:** Stores shader parameters (matrices, material properties, lighting data) updated per-frame or per-draw.

**Characteristics:**
- Small size (typically <64KB due to `maxUniformBufferRange` limits)
- CPU writes frequently
- GPU reads during shader execution
- Fast updates critical for performance

**Configuration:**
```clojure
(buffer! device
  :size uniform-data-size
  :usage #{:uniform-buffer}
  :memory-usage :auto-prefer-device
  :allocation-flags #{:host-access-sequential-write :mapped})
```

**Notes:** Keep uniform buffers small. For large datasets, use storage buffers instead. Consider using push constants for very small updates (<128 bytes).

---

## Storage Buffer (Shader Read/Write)

**Purpose:** Large buffers for compute shaders or complex rendering (SSBO). Supports both reads and writes from shaders.

**Characteristics:**
- Can be very large (gigabytes)
- GPU reads and writes
- May need CPU access for initialization or readback

**Configuration (GPU-only):**
```clojure
(buffer! device
  :size storage-data-size
  :usage #{:storage-buffer :transfer-dst})
```

**Configuration (CPU-writable):**
```clojure
(buffer! device
  :size storage-data-size
  :usage #{:storage-buffer}
  :memory-usage :auto-prefer-device
  :allocation-flags #{:host-access-sequential-write :mapped})
```

**Notes:** Storage buffers have much higher size limits than uniform buffers. Check `maxStorageBufferRange` device limit.

---

## Readback Buffer (GPU → CPU Transfer)

**Purpose:** Reading GPU results back to CPU (screenshots, compute results, GPU profiling data).

**Characteristics:**
- Lives in CPU-accessible memory
- Written by GPU (via transfer or compute)
- Read by CPU with caching for performance
- Random access pattern common

**Configuration:**
```clojure
(buffer! device
  :size result-data-size
  :usage #{:transfer-dst}
  :memory-usage :auto-prefer-host
  :allocation-flags #{:host-access-random :mapped})
```

**Notes:** The `:host-access-random` flag hints that you'll read the data (unlike staging buffers which are write-only). Use cached memory for faster CPU reads.

---

## Indirect Draw Buffer

**Purpose:** Stores draw commands generated by GPU (for GPU-driven rendering, culling, LOD).

**Characteristics:**
- Written by compute shaders
- Read by indirect draw commands
- Enables GPU to decide what to render without CPU involvement

**Configuration:**
```clojure
(buffer! device
  :size indirect-commands-size
  :usage #{:indirect-buffer :storage-buffer})
```

**Notes:** Requires `multi-draw-indirect` device feature. The `:storage-buffer` usage allows compute shaders to write draw commands.

---

## Scratch Buffer (Temporary GPU Work)

**Purpose:** Temporary buffer for compute shader intermediate results, not needed after computation.

**Characteristics:**
- GPU-only access
- Short lifetime
- Can use `:strategy-min-time` for fastest allocation

**Configuration:**
```clojure
(buffer! device
  :size scratch-size
  :usage #{:storage-buffer}
  :allocation-flags #{:strategy-min-time})
```

**Notes:** For frequently allocated/deallocated buffers, consider using custom VMA memory pools (not yet implemented in Sandalphon).

---

## Transform Feedback Buffer

**Purpose:** Captures vertex shader outputs for later use (geometry processing, GPU particle systems).

**Characteristics:**
- Written by vertex/geometry shaders
- Read by subsequent draw calls or CPU

**Configuration (GPU readback):**
```clojure
(buffer! device
  :size transform-feedback-size
  :usage #{:transform-feedback-buffer-ext :vertex-buffer})
```

**Configuration (CPU readback):**
```clojure
(buffer! device
  :size transform-feedback-size
  :usage #{:transform-feedback-buffer-ext :transfer-src}
  :allocation-flags #{:host-access-random :mapped})
```

**Notes:** Requires `transform-feedback` extension. Useful for GPU-driven animation systems.

---

## Shader Binding Table (Ray Tracing)

**Purpose:** Stores ray tracing shader handles for ray generation, closest hit, miss, and intersection shaders.

**Characteristics:**
- Small buffer with strict alignment requirements
- Read by ray tracing pipeline
- Typically static after initialization

**Configuration:**
```clojure
(buffer! device
  :size sbt-size
  :usage #{:shader-binding-table-khr :transfer-dst})
```

**Notes:** Requires ray tracing extension. Check `shaderGroupBaseAlignment` and `shaderGroupHandleSize` properties for alignment requirements.

---

## General Guidelines

### Memory Usage Modes

- **Default (`:auto-prefer-device`)** - Best for GPU-only data or infrequent updates
- **`:auto-prefer-host`** - Best for frequent CPU writes or CPU readback
- **`:auto`** - Let VMA decide based on usage flags (usually same as `:auto-prefer-device`)

### Allocation Flags

- **`:mapped`** - Keep buffer persistently mapped (low overhead for CPU access)
- **`:host-access-sequential-write`** - CPU writes sequentially (staging, updates)
- **`:host-access-random`** - CPU reads randomly (readback, cached memory)
- **`:dedicated-memory`** - Force dedicated allocation (for very large buffers or performance-critical cases)
- **`:strategy-min-time`** - Prefer allocation speed over memory efficiency (temporary buffers)
- **`:strategy-min-memory`** - Prefer memory efficiency over speed (long-lived buffers)

### Performance Tips

1. **Batch transfers** - Use one large staging buffer for multiple transfers rather than many small ones
2. **Persistent mapping** - Use `:mapped` flag for frequently accessed buffers to avoid map/unmap overhead
3. **Minimize CPU-GPU transfers** - Keep data on GPU when possible
4. **Use appropriate memory** - Don't make everything HOST_VISIBLE unless you need CPU access
5. **Reuse buffers** - For dynamic data, reuse the same buffer rather than create/destroy each frame
6. **Check device limits** - Query `maxUniformBufferRange`, `maxStorageBufferRange` before creating large buffers

### Common Usage Flag Combinations

```clojure
;; Static geometry (upload once via staging buffer)
:usage #{:vertex-buffer :transfer-dst}

;; Dynamic geometry (CPU updates each frame)
:usage #{:vertex-buffer}
:allocation-flags #{:host-access-sequential-write :mapped}

;; Compute shader in/out
:usage #{:storage-buffer :transfer-dst :transfer-src}

;; Multi-purpose buffer (flexibility vs optimization)
:usage #{:vertex-buffer :index-buffer :storage-buffer :transfer-dst :transfer-src}
```

### When to Use Staging Buffers

Use the staging buffer pattern when:
- Data is static after upload
- Data is large (>1MB)
- GPU needs optimal performance

Skip staging and use direct CPU-writable buffers when:
- Data updates every frame
- Data is small (<64KB)
- Simplicity matters more than maximum performance
